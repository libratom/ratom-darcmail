<!--# 
This template represents the EAXS <Message> element.
It is related to the lib.message_object.MessageObject module.

Note: the custom "skipnull" filter is used so that elements with null values will not appear in the
rendered EAXS file.

TODO:
* For this and all included templates you need to make sure the correct xs:type will always be
present (valid identifiers, etc.).
#-->

<Message>

    <!--# TODO: RelPath is supposed to be the containing folder not the file. Adding a Header is a 
    bad way of getting the filename and this is what TOMES DarcMail does.
    Something like "inbox#1_.eml" is still a URI but not a folder per the EAXS XSD.
    Because <MessageId> is optional and can be "supplied", I'd rather put this data there and use 
    RelPath as intended. Alternatively, just put it in an XML comment - that's probably best.
    The real issue is that EAXS doesn't have this concept because it isn't an EML-aware schema and
    because folders take precedent over messages. #-->
    <RelPath>{{ message.rel_path |normalize_path }}</RelPath>
    <LocalId>{{ message.local_id }}</LocalId>

    <!--# If the "message-id" header doesn't exist, make an id and set @Supplied to True. #-->
    {% set message_id = message.get("message-id") %}
    {% set message_el = (message_id, "false") if message_id else ("{}_{}".format(
        message.account.global_id, message.local_id), "true") %}
    <MessageId Supplied="{{ message_el[1] }}">{{ message_el[0] |cdata }}</MessageId>
    
    <MimeVersion>{{ message.get("mime-version") }}</MimeVersion>

    <!--# 
    TODO: CHECK ALL .get() string request values! Are you using the right ones?
    TODO: These need to be repeatable: TO, CC, BCC, IN REPLY TO, REFERENCES, COMMENTS, KEYWORDS.
    TODO: Is Sender always returned? If it's xs:string does it matter since blanks are OK?
    #-->
    <OrigDate>{{ message.get("orig-date") |skipnull }}</OrigDate>
    <From>{{ message.get("from") |cdata }}</From>
    <Sender>{{ message.get("sender") |cdata }}</Sender>
    <To>{{ message.get("to") |cdata }}</To>
    <Cc>{{ message.get("cc") |skipnull |cdata }}</Cc>
    <Bcc>{{ message.get("bcc") |skipnull |cdata }}</Bcc>
    <InReplyTo>{{ message.get("in-reply-to") |skipnull |cdata }}</InReplyTo>
    <References>{{ message.get("references") |skipnull |cdata }}</References>
    <Subject>{{ message.get("subject") |cdata }}</Subject>
    <Comments>{{ message.get("comments") |skipnull |cdata }}</Comments>
    <Keywords>{{ message.get("keywords") |skipnull |cdata }}</Keywords> 

    <!--#
    TODO: What's the source for the optional <Comments> element? I can't find anything in RFC 4021
    (at least I think that's the correct spec to look at).
    #-->
    {% for name, value in message.items() %}
    <Header>
        <Name>{{ name }}</Name>
        <Value>{{ value |cdata }}</Value>
        <!--# <Comments></Comments> #-->
    </Header>
    {% endfor %}

    <!--#
    TODO: Put this in a Python script???
    Document that this logic is based on
    https://wingware.com/psupport/python-manual/2.5/lib/mailbox-mboxmessage.html

    Also, is there support for "Draft" or "Recent" in other DarcMail packages?
    #-->
    {% set status = message.get("status", failobj="") + message.get("x-status", failobj="") %}
    {% set status_dict = {"R": "Seen", "A": "Answered", "F": "Flagged", "D": "Deleted"} %}
    {% for status_item in status |trim %}
    <StatusFlag>{{ status_dict.get(status_item) |skipnull }}</StatusFlag>
    {% endfor %}

    <!--# Add <MultiBody> element for a multi-part message; otherwise add <SingleBody>.
    Note: SingleBody.xml needs an object called @msg, hence the "set msg = message" below. #-->
    {% if not message.is_multipart() %}
        {% set msg = message %}
        {% filter indent(width=4, first=True) %}
            {% include "SingleBody.xml" %}
        {% endfilter %}
    {% else %}
        {% filter indent(width=4, first=True) %}
            {% include "MultiBody.xml" %}
        {% endfilter %}
    {% endif %}

    {% for type, location in message.parse_errors %}
    <Incomplete>
        <ErrorType>Python: {{ type }}</ErrorType>
        <ErrorLocation>{{ location }}</ErrorLocation>
    </Incomplete>
    {% endfor %}

    <Eol>{{ EAXSHelpers.get_eol(message) }}</Eol>

</Message>

<!--# Force a line break. #-->
{% raw %}{% endraw %}
