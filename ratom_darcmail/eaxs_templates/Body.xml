
<!--# 
TODO:
    * Make sure you use skipnull and cdata wherever needed.
    * Check all elements against schema for what elements are repeatable and make sure you are
    supporting that.
#-->

            <!--# Get content type. If there is no Content-Type, this falls back to 
            message.get_default_type() aka "text/plain" as required by EAXS. #-->
            <ContentType>{{ message.get_content_type() }}</ContentType>
            
            <Charset>{{ message.get_content_charset(failobj="us-ascii") }}</Charset>

            <!--# TODO: check RFC-4021 for the source of this. It's optional BTW.
            FYI: TOMES DarcMail equates this to Content-Description. #-->
            <ContentName>{{ message.get_params(header="content-description") | skipnull | cdata }}</ContentName>
            
            <!--# TODO: check RFC-4021 for the souce of this. It's optional BTW. #-->
            <ContentTypeComments></ContentTypeComments>
            
            <!--# TODO: document this. 
            This is another candidate for external logic. 
            #-->
            {% set message_params = message.get_params() %}
            {% for name, value in message_params %}
                {% if name.lower() in ["id", "name"] or ("/" in name and value == "") %}
                    {% set message_params = message_params.remove((name, value)) %}
                {% endif %}
            {% endfor %}
            {% if message_params|length > 0 %}
            <ContentTypeParam>
            {% for name, value in message_params %}
                <Name>{{ name }}</Name>
                <Value>{{ value }}</Value>
            {% endfor %}
            </ContentTypeParam>
            {% endif %}

            <TransferEncoding>{{ message.get("content-transfer-encoding") | skipnull }}</TransferEncoding>
            
            <!--# TODO: check RFC-4021 for the souce of this. It's optional BTW. #-->
            <TransferEncodingComments></TransferEncodingComments>

            <ContentId>{{ message.get("content-id") | skipnull | cdata }}</ContentId>
  
            <!--# TODO: check RFC-4021 for the souce of this. It's optional BTW. #-->
            <ContentIdComments></ContentIdComments>

            <!--# TODO: still check RFC-4021 for the souce of this; because it's not clear what this
            element is about. It's optional BTW. #-->
            <Description>{{ message.get("content-description") | skipnull | cdata }}</Description>
            
            <!--# TODO: check RFC-4021 for the souce of this. It's optional BTW. #-->
            <DescriptionComments></DescriptionComments>

            <Disposition>{{message.get_content_disposition() | skipnull }}</Disposition>


<!-- START HERE ... -->
            <element name="DispositionFileName" type="string" minOccurs="0"/>
            <!-- DarcMail: Account().folders[0].messages[0].get_filename() -->
            <element name="DispositionComments" type="string" minOccurs="0"/>
            <!-- ??? check RFC-4021 -->
            <element name="DispositionParams" type="xm:parameter-type" minOccurs="0" maxOccurs="unbounded">
              <annotation>
                <documentation>Any other parameter found in the Content-Disposition header field except for filename.</documentation>
              </annotation>
            </element>
            <!-- DarcMail: 
            
            params = Account().folders[0].messages[0].get_params(header="content-disposition")
            if params is None:
              ???
            for param in params:
              n, v = param
              if n.lower() in ["filename"]:
                continue
              if "/" in n and v == "":
                continue
              <Name>, <Value> = n, v
              
            Note: This is unique to SingleBody becuase it's plural: "paraMS".
            This is a mistake in MultiBody because it should be plural there as well. This is noted in the tomes-eaxs repo.
            -->
            <element name="OtherMimeHeader" type="xm:header-type" minOccurs="0" maxOccurs="unbounded"/>
            <!-- Skip. This is completely unclear.
            Not currently implemented either.
            -->
            <choice minOccurs="0" maxOccurs="1">
              <element name="BodyContent" type="xm:int-body-content-type">
                <annotation>
                        <documentation>This is textual or binary data that is stored in-line in this XML document that makes up the body of this entity. Along with the character set and transfer encoding used.</documentation>
                </annotation>
              </element>
              <element name="ExtBodyContent" type="xm:ext-body-content-type">
                <annotation>
                        <documentation>This is a pointer to a file that contains the text or binary data that makes up the body of this entity. Along with the character set and transfer encoding used.</documentation>
                </annotation>
              </element>
              <element name="ChildMessage" type="xm:child-message-type"/>
              <!-- This doesn't appear to be implemented at all in current DarcMail.
              It's not clear from EAXS XSD what this is even supposed to mean.
              -->
            </choice>
            <element name="PhantomBody" type="string" minOccurs="0">
              <annotation>
                <documentation>Used for Content-Type message/external-body. US-ASCII character set is assumed.</documentation>
              </annotation>
            </element>
            <!-- Not currently implemented.
            Skip ???
            This is unclear.
            -->
    </sequence>
  </complexType>